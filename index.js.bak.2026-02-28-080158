require("dotenv").config();
const { Client, GatewayIntentBits } = require("discord.js");
const { LavalinkManager } = require("lavalink-client");

// ---- Crash visibility (so it never exits silently) ----
process.on("unhandledRejection", (reason) => console.error("UNHANDLED_REJECTION:", reason));
process.on("uncaughtException", (err) => console.error("UNCAUGHT_EXCEPTION:", err));
process.on("exit", (code) => console.log("PROCESS_EXIT:", code));
process.on("SIGTERM", () => console.log("SIGTERM received"));
process.on("SIGINT", () => console.log("SIGINT received"));

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates],
});

client.lavalink = new LavalinkManager({
  nodes: [
    {
      authorization: process.env.LAVALINK_PASSWORD,
      host: process.env.LAVALINK_HOST,
      port: Number(process.env.LAVALINK_PORT),
      id: "local",
      secure: false,
      retryAmount: 10,
      retryDelay: 5_000,
    },
  ],
  sendToShard: (guildId, payload) =>
    client.guilds.cache.get(guildId)?.shard?.send(payload),
  autoSkip: true,
  client: { id: process.env.CLIENT_ID },

  // ---- enable debug events (includes no-audio diagnostics) ----
  advancedOptions: {
    enableDebugEvents: true,
    debugOptions: { noAudio: true },
  },

  playerOptions: {
    defaultSearchPlatform: process.env.SEARCH_SOURCE || "ytmsearch",
    onEmptyQueue: { destroyAfterMs: 30_000 },
    onDisconnect: { autoReconnect: true, destroyPlayer: false },
  },
});

// Forward gateway payloads to lavalink-client (required)
client.on("raw", (d) => client.lavalink.sendRawData(d));

client.once("ready", () => {
  console.log(`âœ… Logged in as ${client.user.tag}`);
  client.lavalink.init({ ...client.user });
});

// ---- Node events ----
const nm = client.lavalink.nodeManager;
if (nm?.on) {
  nm.on("connect", (node) => console.log(`ğŸŸ© node connect: ${node.id}`));
  nm.on("disconnect", (node, reason) => console.log(`ğŸŸ¥ node disconnect: ${node.id} reason=${reason}`));
  nm.on("error", (node, error) => console.error(`ğŸŸ¥ node error: ${node.id}`, error));
}

// ---- Player/track events ----
client.lavalink.on("playerCreate", (player) =>
  console.log(`ğŸ›ï¸ playerCreate guild=${player.guildId} vc=${player.voiceChannelId}`)
);
client.lavalink.on("playerDestroy", (player, reason) =>
  console.log(`ğŸ§¨ playerDestroy guild=${player.guildId} reason=${reason || "n/a"}`)
);
client.lavalink.on("playerSocketClosed", (player, payload) =>
  console.log(`ğŸ”Œ playerSocketClosed guild=${player.guildId}`, payload)
);
client.lavalink.on("trackStart", (player, track) =>
  console.log(`â–¶ï¸ trackStart guild=${player.guildId} title=${track?.info?.title}`)
);
client.lavalink.on("trackError", (player, track, payload) => {
  console.log(`ğŸ’¥ trackError guild=${player.guildId} title=${track?.info?.title}`);
  console.log("trackError payload:", payload);
});
client.lavalink.on("trackStuck", (player, track, payload) => {
  console.log(`â¸ï¸ trackStuck guild=${player.guildId} title=${track?.info?.title}`);
  console.log("trackStuck payload:", payload);
});

// ---- Internal debug logs (includes no-audio diagnostics) ----
client.lavalink.on("debug", (eventKey, eventData) => {
  console.log(`ğŸ§© DEBUG [${eventKey}]`, eventData);
});

function getVoiceChannelId(interaction) {
  return interaction.member?.voice?.channelId || null;
}

async function getOrCreatePlayer(interaction) {
  const guildId = interaction.guildId;
  const voiceChannelId = getVoiceChannelId(interaction);
  if (!voiceChannelId) return { player: null, error: "Join a voice channel first." };

  let player = client.lavalink.getPlayer(guildId);
  if (!player) {
    player = client.lavalink.createPlayer({
      guildId,
      voiceChannelId,
      textChannelId: interaction.channelId,
      selfDeaf: true,
      volume: 100,
    });
  }

  await player.connect();
  return { player, error: null };
}

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isChatInputCommand()) return;

  console.log(`ğŸŸ¦ CMD /${interaction.commandName} by ${interaction.user.tag}`);

  try {
    if (interaction.commandName === "join") {
      const { error } = await getOrCreatePlayer(interaction);
      if (error) return interaction.reply({ content: `âŒ ${error}`, ephemeral: true });
      return interaction.reply("âœ… Joined your voice channel.");
    }

    if (interaction.commandName === "play") {
      await interaction.deferReply();
      const { player, error } = await getOrCreatePlayer(interaction);
      if (error) return interaction.editReply(`âŒ ${error}`);

      const query = interaction.options.getString("query", true);
      const source = process.env.SEARCH_SOURCE || "ytmsearch";
      console.log(`ğŸ” searching source=${source} query="${query}"`);

      const res = await player.search({ query, source }, interaction.user);
      const track = res?.tracks?.[0];
      if (!track) return interaction.editReply("âŒ No results found.");

      console.log(`â• queue add title="${track.info.title}"`);
      player.queue.add(track);

      if (!player.playing) {
        console.log("ğŸšï¸ calling player.play()");
        await player.play();
      }

      return interaction.editReply(`ğŸ¶ Queued: **${track.info.title}**`);
    }

    if (interaction.commandName === "skip") {
      const player = client.lavalink.getPlayer(interaction.guildId);
      if (!player) return interaction.reply({ content: "âŒ Nothing is playing.", ephemeral: true });
      await player.skip();
      return interaction.reply("â­ï¸ Skipped.");
    }

    if (interaction.commandName === "stop") {
      const player = client.lavalink.getPlayer(interaction.guildId);
      if (!player) return interaction.reply({ content: "âŒ No player active.", ephemeral: true });
      await player.destroy();
      return interaction.reply("ğŸ›‘ Stopped and left voice.");
    }
  } catch (err) {
    console.error("ERR:", err);
    if (interaction.deferred || interaction.replied) {
      return interaction.editReply("âŒ Error. Check VPS logs.");
    }
    return interaction.reply({ content: "âŒ Error. Check VPS logs.", ephemeral: true });
  }
});

client.login(process.env.DISCORD_TOKEN);
