require("dotenv").config();
const { Client, GatewayIntentBits } = require("discord.js");
const { LavalinkManager } = require("lavalink-client");

const client = new Client({
  intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildVoiceStates],
});

client.lavalink = new LavalinkManager({
  nodes: [
    {
      authorization: process.env.LAVALINK_PASSWORD,
      host: process.env.LAVALINK_HOST,
      port: Number(process.env.LAVALINK_PORT),
      id: "local",
      secure: false,
      retryAmount: 10,
      retryDelay: 5_000,
    },
  ],
  sendToShard: (guildId, payload) =>
    client.guilds.cache.get(guildId)?.shard?.send(payload),
  autoSkip: true,
  client: { id: process.env.CLIENT_ID },
  playerOptions: {
    defaultSearchPlatform: process.env.SEARCH_SOURCE || "ytmsearch",
    onEmptyQueue: { destroyAfterMs: 30_000 },
    onDisconnect: { autoReconnect: true, destroyPlayer: false },
  },
});

client.on("raw", (d) => client.lavalink.sendRawData(d));

client.once("ready", () => {
  console.log(`âœ… Logged in as ${client.user.tag}`);
  client.lavalink.init({ ...client.user });
});

function getVoiceChannelId(interaction) {
  return interaction.member?.voice?.channelId || null;
}

async function getOrCreatePlayer(interaction) {
  const guildId = interaction.guildId;
  const voiceChannelId = getVoiceChannelId(interaction);
  if (!voiceChannelId) return { player: null, error: "Join a voice channel first." };

  let player = client.lavalink.getPlayer(guildId);
  if (!player) {
    player = client.lavalink.createPlayer({
      guildId,
      voiceChannelId,
      textChannelId: interaction.channelId,
      selfDeaf: true,
      volume: 100,
    });
  }

  await player.connect();
  return { player, error: null };
}

client.on("interactionCreate", async (interaction) => {
  if (!interaction.isChatInputCommand()) return;

  try {
    if (interaction.commandName === "join") {
      const { player, error } = await getOrCreatePlayer(interaction);
      if (error) return interaction.reply({ content: `âŒ ${error}`, ephemeral: true });
      return interaction.reply("âœ… Joined your voice channel.");
    }

    if (interaction.commandName === "play") {
      await interaction.deferReply();
      const { player, error } = await getOrCreatePlayer(interaction);
      if (error) return interaction.editReply(`âŒ ${error}`);

      const query = interaction.options.getString("query", true);
      const source = process.env.SEARCH_SOURCE || "ytmsearch";

      const res = await player.search({ query, source }, interaction.user);
      const track = res?.tracks?.[0];
      if (!track) return interaction.editReply("âŒ No results found.");

      player.queue.add(track);
      if (!player.playing) await player.play();

      return interaction.editReply(`ğŸ¶ Queued: **${track.info.title}**`);
    }

    if (interaction.commandName === "skip") {
      const player = client.lavalink.getPlayer(interaction.guildId);
      if (!player) return interaction.reply({ content: "âŒ Nothing is playing.", ephemeral: true });

      await player.skip();
      return interaction.reply("â­ï¸ Skipped.");
    }

    if (interaction.commandName === "stop") {
      const player = client.lavalink.getPlayer(interaction.guildId);
      if (!player) return interaction.reply({ content: "âŒ No player active.", ephemeral: true });

      await player.destroy();
      return interaction.reply("ğŸ›‘ Stopped and left voice.");
    }
  } catch (err) {
    console.error("ERR:", err);
    if (interaction.deferred || interaction.replied) {
      return interaction.editReply("âŒ Error. Check VPS logs.");
    }
    return interaction.reply({ content: "âŒ Error. Check VPS logs.", ephemeral: true });
  }
});

client.login(process.env.DISCORD_TOKEN);
